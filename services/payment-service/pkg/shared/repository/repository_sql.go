// Code generated by candi v1.18.8.

package repository

import (
	"context"
	"database/sql"
	"fmt"

	// @candi:repositoryImport
	checkoutrepo "payment-service/internal/modules/checkout/repository"
	paymentrepo "payment-service/internal/modules/payment/repository"
	bankrepo "payment-service/internal/modules/bank/repository"
	categoryrepo "payment-service/internal/modules/category/repository"
	methodrepo "payment-service/internal/modules/method/repository"
	providerrepo "payment-service/internal/modules/provider/repository"

	"github.com/golangid/candi/candishared"
	"github.com/golangid/candi/tracer"

	"payment-service/pkg/shared"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

type (
	// RepoSQL abstraction
	RepoSQL interface {
		WithTransaction(ctx context.Context, txFunc func(ctx context.Context) error) (err error)

		// @candi:repositoryMethod
		CheckoutRepo() checkoutrepo.CheckoutRepository
		PaymentRepo() paymentrepo.PaymentRepository
		ProviderRepo() providerrepo.ProviderRepository
		MethodRepo() methodrepo.MethodRepository
		CategoryRepo() categoryrepo.CategoryRepository
		BankRepo() bankrepo.BankRepository
	}

	repoSQLImpl struct {
		readDB, writeDB *gorm.DB

		// register all repository from modules
		// @candi:repositoryField
		checkoutRepo checkoutrepo.CheckoutRepository
		paymentRepo paymentrepo.PaymentRepository
		providerRepo providerrepo.ProviderRepository
		methodRepo   methodrepo.MethodRepository
		categoryRepo categoryrepo.CategoryRepository
		bankRepo     bankrepo.BankRepository
	}
)

var (
	globalRepoSQL RepoSQL
)

// setSharedRepoSQL set the global singleton "RepoSQL" implementation
func setSharedRepoSQL(readDB, writeDB *sql.DB) {
	gormRead, err := gorm.Open(postgres.New(postgres.Config{
		Conn: readDB,
	}), &gorm.Config{})
	if err != nil {
		panic(err)
	}

	gormWrite, err := gorm.Open(postgres.New(postgres.Config{
		Conn: writeDB,
	}), &gorm.Config{SkipDefaultTransaction: true})
	if err != nil {
		panic(err)
	}

	shared.AddGormCallbacks(gormRead)
	shared.AddGormCallbacks(gormWrite)

	globalRepoSQL = NewRepositorySQL(gormRead, gormWrite)
}

// GetSharedRepoSQL returns the global singleton "RepoSQL" implementation
func GetSharedRepoSQL() RepoSQL {
	return globalRepoSQL
}

// NewRepositorySQL constructor
func NewRepositorySQL(readDB, writeDB *gorm.DB) RepoSQL {

	return &repoSQLImpl{
		readDB: readDB, writeDB: writeDB,

		// @candi:repositoryConstructor
		checkoutRepo: checkoutrepo.NewCheckoutRepoSQL(readDB, writeDB),
		paymentRepo: paymentrepo.NewPaymentRepoSQL(readDB, writeDB),
		providerRepo: providerrepo.NewProviderRepoSQL(readDB, writeDB),
		methodRepo:   methodrepo.NewMethodRepoSQL(readDB, writeDB),
		categoryRepo: categoryrepo.NewCategoryRepoSQL(readDB, writeDB),
		bankRepo:     bankrepo.NewBankRepoSQL(readDB, writeDB),
	}
}

// WithTransaction run transaction for each repository with context, include handle canceled or timeout context
func (r *repoSQLImpl) WithTransaction(ctx context.Context, txFunc func(ctx context.Context) error) (err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "RepoSQL:Transaction")
	defer trace.Finish()

	tx, ok := candishared.GetValueFromContext(ctx, candishared.ContextKeySQLTransaction).(*gorm.DB)
	if !ok {
		tx = r.writeDB.Begin()
		if tx.Error != nil {
			return tx.Error
		}

		defer func() {
			if err != nil {
				tx.Rollback()
				trace.SetError(err)
			} else {
				tx.Commit()
			}
		}()
		ctx = candishared.SetToContext(ctx, candishared.ContextKeySQLTransaction, tx)
	}

	errChan := make(chan error)
	go func(ctx context.Context) {
		defer func() {
			if r := recover(); r != nil {
				errChan <- fmt.Errorf("panic: %v", r)
			}
			close(errChan)
		}()

		if err := txFunc(ctx); err != nil {
			errChan <- err
		}
	}(ctx)

	select {
	case <-ctx.Done():
		return fmt.Errorf("Canceled or timeout: %v", ctx.Err())
	case e := <-errChan:
		return e
	}
}

// @candi:repositoryImplementation
func (r *repoSQLImpl) CheckoutRepo() checkoutrepo.CheckoutRepository {
	return r.checkoutRepo
}

func (r *repoSQLImpl) PaymentRepo() paymentrepo.PaymentRepository {
	return r.paymentRepo
}

func (r *repoSQLImpl) ProviderRepo() providerrepo.ProviderRepository {
	return r.providerRepo
}

func (r *repoSQLImpl) MethodRepo() methodrepo.MethodRepository {
	return r.methodRepo
}

func (r *repoSQLImpl) CategoryRepo() categoryrepo.CategoryRepository {
	return r.categoryRepo
}

func (r *repoSQLImpl) BankRepo() bankrepo.BankRepository {
	return r.bankRepo
}
